# REST, URI/URL

----

스터디원들의 개별 정리자료 링크

* [김민섭](https://www.notion.so/b3aa96dfd30c4c70968de50ba1e6c666)
* [이혁진](https://www.notion.so/hyukhyukk/REST-URI-URL-79c515e6dc6145fca0cbde84ee00ca3b)
* [정회형](https://www.notion.so/hotheadfactory/REST-URI-URL-797e9cbb54a842de8e9aa84aa22cb957) (편집자)
* [김종근](https://github.com/Bellroute/TIL/blob/master/Network/REST.md)

##  REST란

### REST는 웹의 아키텍쳐 스타일이다.

- 아키텍쳐 스타일은 '아키텍쳐 패턴'이라고도 하며,
- 복수의 아키텍쳐의 공통된 성질, 양식, 규정 혹은 독특한 방식을 가리키는 말이다.
- **제약 조건의 집합**이라고 볼 수 있으며 아키텍쳐 스타일에 속한 제약조건을 **모두 지켜야** 아키텍쳐 스타일을 따른다고 볼 수 있음.

**아키텍쳐**와 **아키텍쳐 스타일**은 별개이다.

- 실제 시스템은 구체적인 아키텍쳐를 가지고 있지만
- 그 아키텍처를 설계할 때, 설계 지침, 규정, 방식 즉, 아키텍처 스타일을 적용한다.
- 시스템의 아키텍처를 결정할 때 나침반이 되는 것이 아키텍처 스타일이다.

REST는 **네트워크 시스템의 아키텍처 스타일**이다.

- 네트워크 시스템의 아키텍처 스타일로서 가장 유명한 것은 클라이언트/서버(Client-Server)이다.
- 웹의 아키텍처 스타일은 REST이기도 하지만, 클라이언트/서버이기도 하다.
  - REST는 클라이언트 서버 구조에서 파생되었기 때문
  - 순수한 클라이언트/서버 아키텍처 스타일에 몇 가지 제약을 더한 것이 REST 아키텍처 스타일이다.
- REST는 웹 전체의 아키텍처 스타일이기도 하며, 개별 웹 서비스와 웹 API의 아키텍처 스타일이기도 하다.
  - 웹 서비스와 웹 API에서도 REST의 규약을 지키는 것은 중요
  - 개별 웹 서비스가 전체의 조화를 무너뜨리면, 전체가 통일된 아키텍처 스타일을 지킬 수 없기 때문

### 리소스(Resource)

- 웹 상에 존재하는 이름을 가진 모든 정보
- 리소스가 이름을 가진다는 것?
  - 어떤 리소스를 다른 리소스와 구별하기 위한 것

리소스 명칭으로서의 URI

- 리소스의 이름이란 URI를 말한다.
- 리소스는 URI로 식별할 수 있다.
  - ex) 서울의 일기 예보 - http://weather.naver.com/rgn/cityWetrWarea.nhn?cityRgnCd=CT001000
- URI를 이용함으로써, 프로그램은 리소스가 표현하는 정보에 접근할 수 있다.

리소스의 어드레스 가능성(Addressability)

- URI가 지니고 있는 리소스를 간단히 가리킬 수 있는 성질
- URI가 없었던 시절에는 특정 파일에 접근하는 방법을 일일이 설명해야 했다.
  - 해당 파일을 ftp.example.com에 두었고, 디렉터리는 /public/data이고, 파일명은 sample_file.gz이고, ...
- URI가 있는 현재는 URI 한 줄로 적어 액세스하는 것이 가능하다.
  - ftp://example.com/public/data/sample_file.gz

복수의 URI를 가진 리소스

- 1개의 리소스는 복수의 URI를 가질 수 있다.
  - 오늘이 2021년 1월 1일이라면
    - http://weather.example.com/seoul/today
    - http://weather.example.com/seoul/2021-01-01
- 하나의 리소스에 URI를 여러 개 붙여 두면, 클라이언트가 리소스에 접근하기 쉬워짐.
- 반면, 어느 것이 정식 URI인지 알기 힘들다.

리소스의 표현과 상태

- 리소스는 ''웹상에 존재하는 정보''라는 추상적인 개념
- 서버-클라이언트 간에 실제로 리소스를 주고 받을 때는 구체적인 데이터를 송신하는데 이 데이터를 '**Resource Representation**'이라고 부른다.
- 또한 리소스에는 '**상태**'라는 것이 있음.
- 시간의 경과에 따라 리소스의 상태가 변하면 그 표현도 변함

### REST 아키텍쳐 스타일의 구성

1. [클라이언트/서버 구조](https://en.wikipedia.org/wiki/Client–server)

   - 웹은 **HTTP라는 프로토콜을 이용해 클라이언트와 서버가 서로 통신하는 아키텍처 스타일**을 채용하고 있음
   - 요청(Request)을 보내면 응답(Response)하는 구조
   - 장점: 단일 컴퓨터 상에서 모든 것을 처리하는 것이 아니라, 클라이언트와 서버로 분리해서 처리할 수 있다.
     - 클라이언트를 멀티 플랫폼으로 구성할 수 있다. (웹에 PC, 휴대전화, 게임기를 통해서도 접속)
     - UI는 클라이언트 담당. 서버는 데이터 스토리지로서의 기능만 제공해도 됨
     - 복수의 서버를 조합해 확장함으로써 가용성 올릴 수 있음

2. 무상태(Stateless) 서버

   - 클라이언트 상태를 서버에서 관리하지 않는 구조
   - 현실적으로는 현재 쿠키와 세션을 통해 상태를 관리하는 HTTP는 REST의 관점에서는 잘못된 확장이지만, 이 기준을 만족하지 못한다고 상태관리를 포기할 수 없는 것이 현실
   - 클라이언트/서버 구조에서 스테이트리스성을 도입한 것이, 클라이언트/스테이트리스 서버구조

3. [캐시 처리 가능(Cacheable)](https://ko.wikipedia.org/wiki/웹_캐시)

   - 한번 가져온 리소스를 클라이언트 쪽에서 캐시하여 재사용
   - 통신량을 줄이고, 네트워크 대역의 이용과 처리시간을 축소하는 장점이 있음
   - 오래된 캐시일 경우 정보의 신뢰성이 떨어지는 단점이 있음

4. 인터페이스 일관성 (Uniform Interface)

   - URI로 지정한 리소스에 대한 조작을 통일되고 한정적인 인터페이스로 수행
   - HTTP 1.1에서 메소드를 8개만으로 정의하여 고정된 8개의 메소드만으로 모든 요청을 처리하는 것
   - 유연성에는 제약이 있지만, 전체적인 아키텍처가 간결해짐
   - 인터페이스 통일을 통해 클라이언트 / 서버 구현의 중립성이 향상
   - REST의 가장 대표되는 특징
   - Uniform Interface의 제약조건
     - identification of resources - 리소스가 uri로 식별되야 한다.
     - manipulation of resources through representations - representation 전송을 통해서 리소스를 조작해야 한다. 리소스를 만들거나 업데이트하거나 삭제할 때 http message에 표현을 담아 전송을 해야한다.
     - **Self-descriptive messages - 메시지는 스스로를 설명해야 한다. 메시지의 내용으로 온전히 해석이 가능해야한다.**
     - **hypermedia as the engine of application state(HATEOAS) - 애플리케이션의 상태는 Hyperlink를 이용해 전이되어야 한다.**
     - (REST API라고 알려진 거의 모든 것들이 3,4번째 제약 조건이 지켜지지 않고 있다고 한다. -그런 REST API로 괜찮은 가 중-)[https://www.youtube.com/watch?v=RP_f5dMoHFc]

   #### 

5. [계층화 시스템(Layered System)](https://en.wikipedia.org/wiki/Layered_system)

   - 유니폼 인터페이스를 통해 얻은 생긴 시스템 계층화시의 이점
   - 각각 컴포넌트들이 컴포넌트 간의 인터페이스를 HTTP로 통일하고 있기 때문에 서버를 통한 클라이언트의 접속도 서버 앞단에 추가된 프록시를 통한 클라이언트의 접속도 모두 같은 인터페이스로로 접속할 수 있음

6. [Code on demand (optional)](https://en.wikipedia.org/wiki/Client-side_scripting)

   - 프로그램 코드를 서버에서 다운받아 클라이언트에서 실행하는 아키텍처 스타일
   - Ex. JavaScript  / Flash / Java 애플릿
   - 클라이언트를 확장할 수 있는 장점이 있음

정리 REST = `ULCODC$SS (Uniform/Layered/CodeOnDemand/Client Cache($)/StatelessServer)`

- 클라이언트/서버 : 유저 인터페이스와 처리를 분리
- 스테이트리스 서버 : 서버 측에서 애플리케이션의 상태를 가지지 않음
- 캐시 : 클라이언트와 서버의 통신 횟수와 양을 감소
- 유니폼 인터페이스 : 인터페이스를 고정
- 계층화 시스템 : 시스템을 계층별로 분리
- 코드 온 디맨드 : 프로그램을 클라이언트에 다운로드하여 실행

> 민섭 : REST란 아키텍처 스타일로 아키텍처를 구성할때 지켜야할 규약을 담은 것이다. 이러한 규약을 모두 잘 지킨 아키텍처만이 RESTful하다고 할 수 있다. 하지만 현실은 설계에 있어서 REST의 규약의 이상과 타협해야하는 부분(쿠키 혹인 세션을 통한 상태정보 관리)도 생긴다. 즉 REST라는 아키텍쳐 스타일을 지킬때 얻을 수 있는 가치를 염두하면서 실제 설계할 아키텍처에는 최대한 이를 고려하여 설계를 해야한다.  물론 무리하게 REST를 채용할 필요는 없다. 다른 아키텍처 스타일을 적용하면 된다.

### REST의 2가지 측면

- REST와 하이퍼미디어
  - 리소스를 링크로 연결하여 하나의 애플리케이션을 구성
- REST와 분산 시스템
  - 링크를 이용한 애플리케이션 실현
  - 링크를 따라 애플리케이션의 상태를 변화시켜 전체적인 성능 저하를 억제

### REST의 의미

REST는 웹 전체의 아키텍처 스타일이다.

우리들이 만드는 웹 서비스나 웹 API는 웹을 구성하는 일부분이고,

이러한 개별 웹 서비스와 웹 API가 RESTful하게 되면, 웹은 전체적으로 좋아질 것

## URI

### URI의 중요성

URI란? 리소스를 통일적으로 식별하는 ID

### URI의 구문

URI는 유일해야 함. 따라서 서로 다른 리소스가 동일한 URI를 가질 수 없음.

**간단한 URI 구성**

1. URI Scheme : http
2. 호스트명 : [blog.examples.com](http://blog.examples.com)
3. 패스 : /entries/1

**복잡한 URI의 구성**

1. URI Scheme : http
2. 사용자 정보 : yohei:pass
3. 호스트명 : [blog.example.com](http://blog.example.com)
4. 포트번호 : 8000
5. 패스 : /search
6. 쿼리 파라미터 : q=test&debug=true
7. URI 프래그먼트 : #n10

### 절대 URI와 상대 URI

절대 URI : 스키마와 호스트를 포함한 URI

상대 URI : 스키마와 호스트를 제외한 경로만 표현한 URI

- 기준이 되는 URI인 `Base URI`가 필요
  1. 리소스의 URI를 Base URI로 하는 방법 :  리소스의 URI를 클라이언트가 가지고 있어야함
  2. Base URI를 명시적으로 저장하는 방법 : HTML혹은 XML에서 명시

### URI와 문자

**URI에서 사용할 수 있는 문자**

- 알파벳 : A-Z, a-z
- 숫자 : 0-9
- 기호 : -.~:@!$&'()           '?'는?

**%인코딩**

```jsx
<http://ko.wikipedia.org/wiki/가>
↓인코딩
<http://ko.wikipedia.org/wiki/%EA%BO%80>
// UTF-8에서 '가'는 %EA%BO%80
```

- %인코딩을 통해 URI에서 사용할 수 없는 문자를 표현
- 인코딩 방식은 UTF-8만 있는 것은 아니지만 대부분 UTF-8을 사용

### URI의 길이 제한

스펙상으로는 길이 제한이 없음.

하지만 브라우저 종류에 따라 길이를 맞춰야 하는 경우도 있음

### 다양한 스키마

http를 대부분 사용하지만 70개(2010년 기준)의 스키마가 존재

### URI 구현에서 주의할 점들

- 상대 URI 해석 : 가능하면 절대 URI를 사용하자
- %인코딩  : UTF-8을 사용하자

### 개념탄탄

URI, URL, URN 비교

- URI는 URL과 URN을 총칭하는 이름
- URL에는 도메인을 갱신하지 않았거나 서버가 어떤 장해로 변경되면 액세스 할 수 없음
- URN은 책에서의 ISBN과 같이 리소스에 도메인명과 별개로 유일한 ID를 부여할 수 있음
  - 리소스를 취득할 수 없기때문에 보급되어 사용되지는 않음
  - URL도 충분히 영속적이게 되어 사용하지 않음

**정리**

- URL : 리소스의 위치를 나타내는 것
- URN : 리소스의 이름을 나타내는 것
- URI : 리소스를 식별하는 것

URL, URN은 리소스를 식별하는 방법이 다른것 뿐이다. 리소스를 식별하기 위한 목적은 같으니 통칭하여 URI라고 부른다.

## URI의 설계

### 쿨한 URI는 변하지 않는다.

쿨한 URI == 좋은 URI == 아름다운 URI == 변하지 않는 URI

### 좀처럼 변하지 않는 URI를 만들기 위해서는

1. 프로그래밍 언어에 의존적인 확장자와 경로를 포함하지 않는다.

   ```html
   ex1) <http://example.com/cgi-bin/login.pl> // pl이라는 특정 확장자가 존재
   ex2) <http://example.com/servlet/LoginServlet> //Java스타일의 네이밍컨벤션
   ```

2. 메서드명과 세션ID를 포함하지 않는다.

3. URI는 리소스를 표현하는 명사로 한다.

   - 행위는 HTTP 메소드로 표현

### URI 사용성

쿨한 URI를 만들어 사용성을 향상시키자

```html
// 쿨하지 못한 URI
<http://example.com/servlet/LoginServlet>
// 쿨한 URI
<http://example.com/login>
```

### URI를 변경하고 싶을 때

Redirect를 활용하여 응답 결과로 바뀐 URI를 전달하는 것이 클라이언트를 배려하는 좋은 방법이다.

### URI 설계의 테크닉

확장자로 표현을 지정한다.

- 의존적인 확장자를 사용하라는 것이 아님

- 의존적이지 않은 확장자를 사용

  ```html
  <http://example.com/2010/05/01/press.ko>
  <http://example.com/2010/05/01/press.en>
  ```

  위와 같이 언어를 지정하는 확장자를 사용

  .html / .txt / .json과 같은 확장자를 붙여 표현하는 것도 좋은 방법

- 매트릭스 URI

  계층을 표현하기 위해서 슬래시(/)를 이용하지만 다차원 표현에는 한계가 있다. 따라서 세미콜론(:) 혹은 콤마(,)를 사용하여 다양한 표현 지원

  - 세미콜론(:) : 순서의 의미가 없다.
  - 콤마(,) : 순서의 의미가 있다.

### URI의 불투명성

가독성을 높이다 보니 사용자가 URI 구조를 추측하여 접근할 수도 있다. 이럴 경우 실제로는 특정 리소스가 존재하지도 않을 수 있는데 이것을 URI의 불투명성이라 한다.

```html
<http://example.com/2010/05/01/press.ko>
<http://example.com/2010/05/01/press.en>
위에 리소스가 있다고
<http://example.com/2010/05/01/press.fr>
도 있을 것이라 추측하는것
```

따라서 설계 시에 이러한 불투명성도 의식해서 구현해야 한다.

### URI를 강하게 의식하기

- URI는 리소스의 이름이다.
- URI는 수명이 길다
- URI는 브라우저가 주소창에 표시한다.



## 그래서 URI와 URL은 뭐가 다르죠?

- URI는 URL과 URN(name)을 총칭하는 이름이다
- URL은 도메인을 갱신하지 않았거나, 장애로 인해 서버가 변경되면 액세스 할 수 없게 되는 문제가 있다
  - 이 문제에 대응하기 위해 도메인명과는 독립적으로 리소스에 항구적인 ID를 할당하기 위한 스펙이 검토됨
  - 이게 URN이다. URN은 리소스에 도메인명과는 독립된 이름을 붙일 수 있다.
    - ex > urn:isbn:9441749174
- but, URN 은 웹에서 보급되어 있다고 할 수 없음
  - 이유 1. URN은 리소스를 취득할 수 없다
    - 서버명과 프로토콜명이 없어서 URI로서 리소스 취득 불가능함
  - 이유 2. URL은 충분히 영속적이 되었다
    - 웹의 가치가 향상되면서 리소스와 URL은 가능한 한 영속으로 액세스 할 수 있도록 해야 한다는 사고가 확산됨에 따라 URN을 사용할 것 까지도 없는 경우가 많아짐
- - URL 은 리소스의 위치를 나타내는 것이고, URN은 이름을 나타내는 것이고, URI 는 리소스를 식별하는 것이라고 할 수 있다.



### 참고

- 유튜브, "그런 REST API로 괜찮은가"
- 웹을 지탱하는 기술
- [지식덤프](http://www.jidum.com/jidums/view.do?jidumId=1002)