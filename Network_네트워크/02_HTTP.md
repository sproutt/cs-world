# HTTP

스터디원들의 개별 정리자료 링크

- [김민섭](https://www.notion.so/b3aa96dfd30c4c70968de50ba1e6c666)
- [이혁진]()
- [정회형](https://www.notion.so/HTTP-4e70342b2a734075986266b6bd4f1de9)
- [김종근](https://github.com/Bellroute/TIL/blob/master/Network/HTTP.md) (편집자)

</br>

### 0. HTTP는 TCP/IP를 기반으로 한다.

웹 서비스는 HTTP(Hyper Text Transfer Protocol)이라는 규칙을 통해 데이터를 주고 받는다. 이 HTTP는 TCP/IP를 기반으로한다. TCP/IP에 대해서 먼저 알아보자.

인터넷의 네트워크 프로토콜은 계층 구조를 가지고 있다. (계층을 나누고 각 계층별로 추상화하여 구현하게 되면 다른 계층의 의존적이지 않고 해당 계층에 대한 구현을 쉽게 할 수 있다는 이점이 있음) 인터넷 계층 구조는 분리된 단계에 따라 OSI 7계층과 TCP/IP 4계층으로 구별하고, 각 층마다 목적에 따라 사용하는 프로토콜이 존재한다. (TCP/IP 4계층 중심으로 설명) 우리가 알아볼 TCP/IP의 TCP는 트랜스포트 계층, IP는 인터넷 계층에서 사용되는 프로토콜이다. IP는 네트워크 인터페이스 계층에 속한 물리적, 전기적 장치와 데이터를 실제로 주고 받는 일을 하고, TCP는 IP가 받아온 데이터의 무결성을 보증하는 역할을 한다. (UDP는 비연결성, 비신뢰적인 통신)

**계층형 프로토콜**

- 네트워크 인터페이스 계층 : LAN
- 인터넷 계층 : IP (패킷)
- 전송 계층 : TCP (세그먼트)
- 애플케이션 계층 : HTTP

**IP 프로토콜**

- 원하는 노드를 식별하기 위한 프로토콜
- 전체 네트워크에서 식별가능한 IP 주소를 부여
- IP 주소를 이용해서 원하는 노드로의 경로를 설정
- 인터넷상의 거의 모든 응용이 IP를 기반으로 하고 있다.
- 노드와 노드 사이에서 경로를 설정하는 컴퓨터를 **라우터**라고 한다. (작게는 2개, 많게는 수십개의 라우터를 거친다.)

**TCP**

- 데이터 흐름을 제어하기 위한 프로토콜
- 데이터는 여러 패킷으로 조각 나서 이동한다.
- 패킷 통신은 네트워크를 효율적으로 활용 (데이터를 쪼개지 않고 통으로 보낸다면 데이터를 다 보낼 때까지 하나의 노드가 회선을 장악해 다른 노드는 네트워크에 참여할 수 없다. 데이터를 쪼갬으로써 여러 노드가 네트워크에 참여할 수 있도록 보장한다.)
- 네트워크 환경에 차이로 패킷은 순서대로 도착하지 않을 수 있고, 잡음으로 인해 데이터가 훼손될 수 있다. 이를 위해 TCP는 데이터 패킷에 대한 일련번호와 전송에 대한 응답이라는 두가지 매커니즘으로 데이터의 흐름을 제어한다.



TCP/IP는 결국 네트워크로부터 받은 데이터를 무결성을 보장하는 역할을 한다. TCP까지 거친 데이터는 애플리케이션 계층으로 전달되는데 애플리케이션 계층에서 데이터를 주고 받는데 사용되는 통신규약이 HTTP이고, HTTP는 이러한 TCP/IP를 기반한다~~는 말을 장황하게 했다~~.



![image-20210218201251096](/Users/bellroot/Library/Application Support/typora-user-images/image-20210218201251096.png)

</br>

### 1. HTTP 버전

#### HTTP 0.9 - HTTP의 탄생

- 사실 0.9 버전은 존재하지 않음. 버너스-리가 1990년에 웹을 발명했을 때 사용하던 프로토콜을 HTTP 0.9버전이라고 부름

- 구조

  ```
  // 요청
  GET /index.html
  
  // 응답
  <html>...</html>
  ```

- 현재 HTTP와 다르게 헤더가 없었음.
- HTTP 메소드로는 GET만 존재했음

#### HTTP 1.0 - HTTP 최초의 표준화

- 구조

  ```
  // 요청
  GET /mypage.html HTTP/1.0
  User-Agent: NCSA_Mosaic/2.0 (Windows 3.1)
  
  // 응답
  200 OK
  Date: Tue, 15 Nov 1994 08:12:31 GMT
  Server: CERN/3.0 libwww/2.17
  Content-Type: text/html
  <HTML>
  A page with an image
    <IMG SRC="/myimage.gif">
  </HTML>
  ```

- 헤더의 도입
- GET 이외의 메소드 추가
- 응답 시작 부분에 상태 코드 추가. 브라우저가 요청에 대한 성공과 실패를 알 수 있게 되었음
- Content-Type 헤더의 도움으로, 평이한 HTML 파일들 외에 다른 문서들을 전송하는 기능 추가

#### HTTP 1.1 - HTTP의 완성

- **지속적 연결** - 커넥션을 재사용하여 시간을 절약
- **파이프라이닝 추가** - 첫번째 요청에 대한 응답이 완전히 전송되기 전에 두번째 요청을 가능케 함 -> 커뮤니케이션 레이턴시 낮춤
- **캐시 제어 메커니즘 도입**
- 언어, 인코딩 혹은 타입을 포함한 **컨텐츠 협상** 도입

#### HTTP 2.0 - 더 나은 성능을 위한 프로토콜

- SPDY라는 구글의 비표준 개방형 네트워크 프로토콜에 기반
- 기존의 HTTP 메소드, 상태코드 개념들이 동일하게 호환된다
- **Frame & Stream & Message**
  - Plain Text(평문)을 사용하던 기본 HTTP와 달리, 바이너리 포맷으로 인코딩된 Message, Frame으로 구성
  - Stream: 구성된 연결 내에서 전달되는 바이트의 양방향의 흐름, 하나 이상의 메시지가 전달 가능
  - Message: 논리적 요청 또는 응답 메시지에 매핑되는 프레임의 전체 시퀀스
  - Frame: HTTP/2에서 통신의 최소 단위. 각 최소 단위에는 하나의 프레임 헤더가 포함. 이 헤더는 최소한으로 프레임이 속하는 스트림을 식별
- **HTTP Header Data Compression(HTTP 헤더 데이터 압축)**
  - 이전 Header의 내용과 중복되는 필드를 재전송하지 않아 데이터를 절약
  - Huffman Coding을 사용하는 HPACK이라는 Header 압축방식을 이용하여 데이터 전송 효율을 높임
- **HOL Blocking 문제 해결**
  - HTTP/1.1까지는 한번에 하나의 파일만 전송 가능했음. 여러 파일을 전송하는 경우, 선행 파일 전송이 늦어지면 전체 파일 전송 시간 늘어났음
  - HTTP/2에서는 여러 파일을 한번에 병렬 전송하여 문제 해결함

#### +) HTTPS

- HTTP 프로토콜의 보안 버전
- 암호화된 전송 계층인 SSL 도입하여 평문이었던 데이터를 암호화 시킴
- 암호화, 인증 및 무결성 보장을 통해 HTTP보다 웹에서 더 안전한 프로토콜임
- 기능
  - 무결성 및 인증
  - 개인 정보
  - 사용자 경험
  - 호환성

</br>

### 2. HTTP 특징

- TCP/IP를 이용하는 응용 프로토콜

- 요청-응답 방식으로 동작

- 비연결성(Statless, Connectless) 프로토콜 (이러한 단점을 해결하기 위해 Cookie와 Session 등장)
- 캐시 기능

</br>

### 3. HTTP 구조

#### 요청

- **요청 라인** : GET /HTTP/1.1
  - 요청 메소드 : GET, POST, PUT, DELETE
  - 요청 URL
  - HTTP 버전
- **요청 헤더**: key-value 형태
  - Accept : 클라이언트가 받을 수 있는 컨텐츠
  - Cookie : 쿠키
  - Content-Type : 메시지 바디 종류
  - Content-:Length : 메시지 바디 길이
- **요청 바디**

#### 응답

- **응답 라인**: HTTP/s.1. 200 OK

  - 버전
  - 상태 코드
  - 상태 메시지 

- **응답 헤더**

  - Content-Type : 바디 데이터의 타입
  - Content-Length : 바디 데이터 크기
  - Set-Cookie : 쿠키 설정
  - Tag : 엔티티 태그

- **응답 바디** : HTML, JSON, Octet Stream 등

- **상태 코드**

  - 1xx : 정보
  - 2xx : 성공
    - 200 : OK. 요청 성공
    - 201 : Created. 생성 요청 성공
    - 202 : Accepted. 요청 수락(처리 보장X)
    - 204 : 성공했으나 돌려줄게 없음

  - 3xx : 리다이렉션
    - 300 : Multiple choices. 여러 리소스에 대한 요청 결과 목록
    - 301,302,303 : Redirect. 리소스 위치가 변경된 상태
    - 304 : Not Modified. 리소스가 수정되지 않았음

  - 4xx : 클라이언트 오류
    - 400 : Bad Request. 요청 오류
    - 401 : Unauthorized. 권한없음
    - 403 : Forbidden. 요청 거부
    - 404 : Not Found. 리소스가 없는 상태

  - 5xx : 서버 오류
    - 500 : Internal Server Error. 서버가 요청을 처리 못함
    - 501 : Not Implemented. 서버가 지원하지 않는 요청
    - 503 : Service Unavailable. 과부하 등으로 당장 서비스가 불가능한 상태

</br>

### 4. HTTP 메소드

이 전에 정리한 내용을 [참고](https://github.com/Bellroute/TIL/blob/master/Network/HTTP%EB%A9%94%EC%86%8C%EB%93%9C.md)

\+) 원래 HTTP 메소드는 PATCH를 제외하고 8개의 메소드만으로 이루어져 있었음. PATCH는 HTTP/1.1버전에 추가되었음

</br>

**4-1. POST를 PUT/DELETE대신 사용하는 방법**

GET/POST 만 이용해야하는 경우

- XHR을 지원하지 않을 겨우
- 보안상의 이유로 GET/POST외의 접근을 제한하는 경우

해결방법

- _method 파라미터에 원래 사용하고자 했던 메소드를 명시 (Content-Type‘ application/x-www-form-urlencoded)
- X-HTTP-Method-Override 헤더 사용 (Ex. X-HTIP-Method-Override: PUT)

</br>

**4-2. 조건부 요청**

HTTP 메서드와 갱신일자 등으로 헤더를 구성하면 메서드의 실행 여부를 리소스의 갱신일자를 조건으로 서버가 선택

- GET + If-Modified-Since : 특정 시간 이후에 갱신되어 있으면 GET 요청
- POST + If-Unmodified-Since : 특정 시간 이후 갱신되어 있지 않으면 리소스 갱신(POST)

</br>

**4-3. 멱등성과 안전성**

멱등성 : 어떤 조작을 몇 번을 반복해도 결과가 동일한 것

안전 : 조작 대상의 리소스의 상태를 변화시키지 않는 것

- **PUT은 멱등** : PUT으로 수정 요청을 하였을 때, 통신에러가 발생하여 응답을 받지 못했다면 다시 같은 요청을 해도 같은 결과를 얻을 수 있기 때문에

- **DELETE도 멱등** : DELETE요청을 하고 200상태코드를 받고나서 다시 요청을 하면 404상태코드를 리턴받지만 리소스가 삭제된 결과는 동

- **GET과 HEAD는 멱등 + 안전** : 몇 번을 해도 같은 결과를 얻고 리소스를 바꾸는 동작이 아니기 때문

- **안전하지도 멱등도 아닌 POST** : 예를 들어 주문 작업과 같은경우 여러번 요청하면 문제가 발생하기 때문

</br>

**4-4. 메서드의 오용**

GET과 HEAD가 멱등이고 안전하다는것과 PUT과 DELETE가 멱등이라는 것은 스펙으로 정의된 것이지만, 옳바르게 사용하지 않으면 안전하지 않을 수도 있다.

예를들어

```jsx
GET / resources/1/delete HTTP/ 1.1 
Host: example.com
```

다음과 같이 요청하게 된다면 GET의 목적을 무시한 요청이고 안전하지 않다.

- **POST 오용** : POST로 모든 요청을 처리할 수 있지만, 다른 메서드를 사용할 수 있음에도 불구하고 지나치게 사용하는 것은 안전문제를 야기시킬 수 있음

- **PUT이 멱등이 아닌경우** : PUT요청이 리소스의 상대적인 차분을 요청하는 경우

- **DELETE가 멱등이 아닌경우** : DELETE요청으로 특정 리소스가 아닌 제일 최신의 데이터가 삭제되는 경우 (예 : alias 리소스) alias리소스는 특별한 이유가 없는 한, 갱신과 삭제 조작이 안되도록 설계해야함

</br>

**웹의 성공 이유는 HTTP 메서드에 있다**

HTTP는 메서드를 아주 적은 수로만 한정하고 고정시켰기 때문에 심플한 프로토콜이 될 수 있었고 이로써 REST의 Uniform 인터페이스를 지키며 확장성이 뛰어난 프로토콜이 되었다.

</br>

**[참고]**

- https://velog.io/@taesunny/HTTP2HTTP-2.0-%EC%A0%95%EB%A6%AC
- 웹을 지탱하는 기술



####  생각해 볼만한 질문

- 공개키와 비공개키
- HTTPS 통신 흐름
- HTTP는 비연결성이 특징인데 왜 연결지향형 프로토콜인 TCP에서 동작하나
- Cookie와 Session의 역할
- HTTP의 가장 큰 장점