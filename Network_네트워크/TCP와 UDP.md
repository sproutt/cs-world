# TCP와 UDP

### 0. 트랜스포트 계층(Transport Layer)

> 트랜스포트 계층(Transport Layer)는 클라이언트와 서버 간에 **애플리케이션 계층 메시지를 전송** 하는 서비스를 제공한다.

- 서로 다른 호스트에서 동작하는 애플리케이션 프로세스 간의 **논리적 통신(logical communication)** 을 제공
  - 논리적 통신 - 애플리케이션 관점에서 보면 프로세스들이 동작하는 호스트들이 직접 연결된 것처럼 보임을 의미
- 네트워크 라우터가 아닌 **종단(end-point) 시스템** 에서 구현된다.
- 송신 측 트랜스포트 계층은 
  - 애플리케이션 프로세스로부터 수신한 메시지를 **세그먼트(segment)** 라는 작은 조각으로 분할하고, 
  - 각각의 조각에 **헤더**를 추가하여 전송한다.
- 수신 측 트랜스포트 계층은
  - 네트워크 계층으로부터 데이터그램에서 추출한 세그먼트를 받고,
  - 애플리케이션에서 세그먼트 내부의 데이터를 이용할 수 있도록 세그먼트를 처리한다.
- <u>트랜스포트 계층은 TCP와 UDP라는 프로토콜이 있다.</u>
  - TCP: 신뢰적이고 연결지향형 서비스를 제공
  - UDP: 비신뢰적이고 비연결형 서비스를 제공



#### 트랜스포트 계층이 없다면?

- 트랜스포트 계층이 없다면, 인터넷 네트워크 계층 프로토콜인 IP(Internet Protocol)을 이용하여 호스트들 간에 논리적 통신을 제공한다.
- IP 서비스 모델은 통신하는 호스트들 간에 세그먼트를 전달하기 위해서 최대한 노력하지만, 어떤 보장도 하지않는다. (비신뢰적인 서비스)
  - 세그먼트의 전달
  - 세그먼트의 순서
  - 세그먼트 내부 데이터의 무결성
- **트랜스포트 다중화&역다중화**에 어려움이 생긴다.
  - 트랜스포트 계층 프로토콜인 UDP와 TCP의 가장 기본적인 기능 
  - "호스트-대-호스트 전달"을 "프로세스-대-프로세스로 전달"로 확장하는 것



#### 트랜스포트 다중화&역다중화?

- **다중화(multiplexing)** 
  - 출발지 호스트에서 (애플리케이션 프로세스의) 소켓으로부터 데이터를 모으고, 
  - 이에 대한 세그먼트를 생성하기 위해서 각 데이터나 헤더 정보로 캡슐화하고, 
  - 그 세그먼트들을 네트워크 계층으로 전달하는 작업
  - 다중화 시
    - 소켓은 **유일한 식별자** 를 가지고, 
    - 세그먼트는 세그먼트가 전달될 적절한 소켓을 가리키는 **특별한 필드** 를 가져야한다.
    - 이 특별한 필드가 우리에게 익숙한 **포트 번호** 다.
- **역다중화(demultiplexing)**
  - 트랜스포트 계층 세그먼트의 데이터를 올바른 소켓으로 전달하는 작업
  - 역다중화 시 
    - 호스트의 각 소켓은 포트 번호를 할당 받고, 
    - 세그먼트가 호스트에 도착하면 트랜스포트 계층은 세그먼트 안의 목적지 포트 번호를 검사하여 상응하는 소켓으로 세그먼트 전달

- UDP와 TCP에서 사용되는 소켓의 식별요소가 각각 다름
  - UDP : 목적지 IP 주소, 목적지 포트 번호 (복귀 주소와 번호는 세그먼트에서 추출)
    - 다른 출발지 정보, 같은 목적지 정보 -> 같은 목적지 소켓
  - TCP : 출발지 IP 주소, 출발지 포트 번호, 목적지 IP 주소, 목적지 포트 번호
    - 다른 출발지 정보, 같은 목적지 정보 -> 다른 목적지 소켓
    - 연결 지향을 위함

</br>

### 1. 비연결형 프로토콜: UDP(User Datagram Protocol)

- UDP는 트랜스포트 계층 프로토콜이 할 수 있는 최소 기능으로 동작한다.
  - 다중화/역다중화 기능
  - 간단한 오류 검사
- 핸드셰이크를 사용하지 않는다.
- 신뢰적인 데이터 전송을 제공하는 TCP가 아닌 UDP가 필요한 이유
  - **무슨 데이터를 언제 보낼지 모르는 경우**
    - TCP는 신뢰적인 전달이 얼마나 오래 걸리는지 관계없이 수신 여부를 확인응답할 때까지 재전송을 계속 할 것임
    - 실시간 서비스와 같이 종종 최소 전송률을 요구하고, 지나치게 지연되는 전송을 윈치 않으며, 조금의 데이터 손실은 허용할 수 있는 경우에는 TCP보다 UDP가 낫다.
  - **연결 설정이 없다 == 연결 지연**
    - TCP는 연결을 설정하기 위해 three-way-handshake를 수행한다. 그만큼 연결을 설정하기 위한 시간이 걸린다.
    - UDP는 연결 설정을 위한 어떤 지연도 없다.
  - **연결 상태가 없다**
    - TCP는 연결 상태를 유지하기 위해 리소스를 사용한다. 이에 반해 UDP는 연결 상태를 유지하거나 기록하지 않는다.
    - TCP보다 UDP에서 좀 더 많은 클라이언트를 수용할 수 있다.
  - **작은 패킷 헤더 오버헤드**
    - TCP 세그먼트의 헤더 오버헤드 - 20바이트
    - UDP 세그먼트의 헤더 오버헤드 - 8바이트

- UDP를 사용하는 대표적인 예 (주로 약간의 데이터 손실을 허용하되, 빠른 전달이 필요한 경우)
  - DNS
  - 네트워크 관리 애플리케이션
  - 스트리밍 멀티미디어

</br>

### 2. 연결지향형 프로토콜: TCP(Transmission Control Protocol)

- TCP는 신뢰적인 데이터 전송을 제공한다.
  - 순서번호 - 패킷에 순서번호를 삽입
  - 확인응답 - 정확하게 수신되었는지 잘못 수신되어 반복이 필요한지 수신자가 송신자에게 알려줘야 함
  - 재전송
  - 흐름제어 - 송신자가 수신자의 버퍼를 오버플로우 시키는 것을 방지
  - 혼잡제어 - 네트워크 내의 패킷 수가 과도하게 증가하는 현상 방지

</br>

- TCP 연결: **3-way-handshake**
  - 송신자 애플리케이션이 데이터를 전송하기 전에 먼저 정확한 전송을 보장하기 위해 수신자 애플리케이션과 사전에 세션을 수립하는 과정을 의미한다
  - **[STEP 1]** Client > Server : TCP SYN
    - A클라이언트는 B서버에 접속을 요청하는 SYN 패킷을 보낸다. 이때 A클라이언트는 SYN 을 보내고 SYN/ACK 응답을 기다리는SYN_SENT 상태가 되는 것이다.
  - **[STEP 2]** Server > Client : TCP SYN ACK
    - B서버는 SYN요청을 받고 A클라이언트에게 요청을 수락한다는 ACK 와 SYN flag 가 설정된 패킷을 발송하고 A가 다시 ACK으로 응답하기를 기다린다. 이때 B서버는 SYN_RECEIVED 상태가 된다.
  - **[STEP 3]** Client > Server : TCP ACK
    - B서버는 SYN요청을 받고 A클라이언트에게 요청을 수락한다는 ACK 와 SYN flag 가 설정된 패킷을 발송하고 A가 다시 ACK으로 응답하기를 기다린다. 이때 B서버는 SYN_RECEIVED 상태가 된다.
  - 양쪽 모두 통신할 준비가 되었다는 것을 보장하고, 실제로 데이터 전달 전에 한쪽이 다른 쪽이 준비되었다는 것을 알수 있음.

</br>

- TCP 연결 종료: **4-way-handshake**
  - **[STEP 1]** Client > Server : TCP FIN
    - 클라이언트가 연결을 종료하겠다는 FIN플래그를 전송한다.
  - **[STEP 2]** Server > Client : TCP ACK
    - 서버는 일단 확인메시지를 보내고 자신의 통신이 끝날때까지 기다리는데 이 상태가 **TIME_WAIT** 상태다.
  - **[STEP 3]**  Server > Client : TCP FIN
    - 서버가 통신이 끝났으면 연결이 종료되었다고 클라이언트에게 FIN플래그를 전송한다.
  - **[STEP 4]**  Client > Server : TCP ACK
    - 클라이언트는 확인했다는 메시지를 보낸다.



### 생각해 볼만한 질문

- DNS 동작 과정을 설명하시오
- TCP는 연결지향인데, 왜 그 위에서 동작하는 HTTP는 비연결성이라는 특징을 갖나?

- UDP와 TCP의 세그먼트 구조
- TCP 연결과 종료 시에 왜 다른 handshake를 사용할까?

- 흐름제어와 혼잡제어 구체적인 동작 과정

- 그런데 만약 "Server에서 FIN을 전송하기 전에 전송한 패킷이 Routing 지연이나 패킷 유실로 인한 재전송 등으로 인해 FIN패킷보다 늦게 도착하는 상황"이 발생한다면 어떻게 될까요? 
  - Client에서 세션을 종료시킨 후 뒤늦게 도착하는 패킷이 있다면 이 패킷은 Drop되고 데이터는 유실될 것입니다. 
  - 이러한 현상에 대비하여 Client는 Server로부터 FIN을 수신하더라도 일정시간(디폴트 240초) 동안 세션을 남겨놓고 잉여 패킷을 기다리는 과정을 거치게 되는데 이 과정을 "TIME_WAIT" 라고 합니다.

- TCP에서 패캣 손실 났을 때 어케하나?

