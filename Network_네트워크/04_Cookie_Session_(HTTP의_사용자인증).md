# HTTP의 사용자 인증

스터디원들의 개별 정리자료 링크

- [김민섭](https://www.notion.so/HTTP-3fd747357f07432f8356f97da2904546) (작성자)
- [정회형](https://www.notion.so/HTTP-111e3f2359f14bdfb736294c51e30902)
- [김종근](https://github.com/Bellroute/TIL/blob/master/Network/%EC%BF%A0%ED%82%A4%EC%99%80_%EC%84%B8%EC%85%98.md)

```
인증 : 유효한 사용자임을 확인함과 동시에 연속적인 요청에 있어서 이전 요청 주체와 현재 요청 주체가 같은지 확인하고 다른 주체가 전송한 요청과 구별하는 절차 (세션기반 인증과 토큰기반 인증에서 바라본 작성자 본인의 주관적인 의견입니다)
```

## 사용자 인증 과정의 발전흐름과 개요

- HTTP의 특성 중 하나는 바로 무상태성이라는 것이다.
- 이는 REST라는 아키텍처 스타일의 무상태원칙을 따르는 것인데, 현실적인 어려움으로 HTTP는 상태 정보를 저장해야할 필요성이 생겼다.
- 이를 위해 가장 쉽게 생각할 수 있는 것은 상태정보를 클라이언트에게 관리하는 것이고 이것이 쿠키이다.
- 하지만 쿠키에 모든 정보를 담아 클라이언트에게 전달하는 것은 보안에 위험이 있다.
- 따라서 중요한 정보는 서버의 세션에 담고 세션의 정보를 확인하기 위한 최소한의 정보만 쿠키로써 클라이언트가 가지고 있는 방식이 나왔다.
- 하지만 이 또한 문제점이 없는것이 아니다. 사용자에 대한 상태정보를 서버에서 관리하는 만큼 추가적인 리소스가 소모가 되고 연결상태에 있는 사용자가 많아질 경우 서버의 부하가 증가한다.
- 따라서 필요한 정보를 담고 있으면서 안정성이 있고, 서버에서는 정보를 기록하지 않고 유효성만 확인하는 방법으로 나온것 즉 무상태성과 보안성을 함께 고려한 방식이 바로 토큰방식이다.
- 다시 한 번 강조하면 토큰기반은 상태유지방법이 아니다.
- 그리고 역시나 토큰기반 방법이 완벽해 보일지라도 취약점은 있다.
- 한 번 발급된 토큰을 탈취했을 경우에 대한 보안 위협도 있고 저장할 데이터가 많아지면 무거워지는 등의 취약좀도 존재한다.
- 따라서 딱 잘라서 어떠한 방식이 좋다고는 말하기 어렵고 적용하려는 WAS의 특성에 적합한 인증방식을 선택하는 것이 중요하다.

## 서버기반인증(쿠키 / 세션)

### 쿠키

**쿠키란?**

- 클라이언트 로컬에 저장되는 키와 값이 들어있는 파일
- 이름, 값, 유효 시간, 경로 등을 포함
- 클라이언트의 상태 정보를 브라우저에 저장하여 참조
- 클라이언트한테 저장
- 보안에 취약
- 만료시간에 따라 브라우저에 남아 있을 수도 있음
- 클라이언트 (웹 브라우저) 에 총 300개, 하나의 도메인당 20개, 개당 4KB를 넘지 않게 저장 가능

**구성요소**

- 이름
- 값
- 만료시간
- 도메인이름
- 경로
- 보안 연결 여부
- HttpOnly 여부

### **동작과정**

1. 웹브라우저가 서버에 요청

2. 상태를 유지하고 싶은 값을 쿠키(cookie)로 생성

3. 서버가 응답할 때 HTTP 헤더(Set-Cookie)에 쿠키를 포함해서 전송

   `Set−Cookie: id=doy`

4. 전달받은 쿠키는 웹브라우저에서 관리하고 있다가, 다음 요청 때 쿠키를 HTTP 헤더에 넣어서 전송

   `cookie: id=doy`

5. 서버에서는 쿠키 정보를 읽어 이전 상태 정보를 확인한 후 응답

### 쿠키의 사용예

- '아이디/비밀번호 저장' 기능 또는 자동 로그인
- 쇼핑몰의 장바구니 기능
- 팝업 광고의 'n일 동안 이 창을 보지 않음' 체크시
  - 쿠키의 만료 시간이 n일 뒤로 발급되기 때문에 그 이후에는 다시 팝업이 뜨는 것이다.
    
-----------------

### 세션

**세션이란?**

- 일정 시간 동안 같은 브라우저로부터 들어오는 요청을 하나의 상태로 보고 그 상태를 유지하는 기술
- 즉, 웹 브라우저를 통해 서버에 접속한 이후부터 브라우저를 종료할 때까지 유지되는 상태
- 서버에서 관리하는 상태저장정보
- 쿠키의 SESSIONID만 저장하여 값으로 구분해 서버에서 처리
- 브라우저 종료시 만료시간에 관계없이 삭제
- 서버의 처리를 필요로해 쿠키에 비해 느림

### **동작과정**

1. 웹브라우저가 서버에 요청

2. 서버가 해당 웹브라우저(클라이언트)에 유일한 ID(Session ID)를 부여함

3. 서버가 응답할 때 HTTP 헤더(Set-Cookie)에 Session ID를 포함해서 전송쿠키에 Session ID를 JSESSIONID 라는 이름으로 저장

   `Set−Cookie: JSESSIONID=xslei13f`

4. 웹브라우저는 이후 웹브라우저를 닫기까지 다음 요청 때 부여된 Session ID가 담겨있는 쿠키를 HTTP 헤더에 넣어서 전송

   `Cookie: JSESSIONID=xslei13f`

5. 서버는 세션 ID를 확인하고, 해당 세션에 관련된 정보를 확인한 후 응답

### 세션 기반 인증의 한계

쿠키-세션(엄밀히 따지자면 세션)을 통해 HTTP의 상태를 유지하여 서비스 이용자를 인증하는 방식을 **세션 기반 인증** 이라고 한다. 이러한 세션 기반 인증 방식은 서비스의 규모가 커질수록 다음과 문제점을 보이기 시작한다.

- 세션으로 인한 서버 부하
  - 세션으로 로그인 중인 사용자를 관리하는 경우, 사용자가 늘어날수록 서버의 RAM에 부하가 걸린다.
  - 이를 피하기 위해 데이터베이스에 저장을 하기도 하는데, 이 방식 역시 데이터베이스에 무리를 준다. + 속도도 느리다.
- 확장성
  - 사용자가 증가함에 따라 더 많은 트래픽을 처리하기 위해 여러 프로세스를 돌리거나 서버 확장이 필요해질 수 있따.
  - 하지만, 세션을 사용한다면 세션을 분산시키는 시스템을 설계해야하지만 과정이 쉽지 않다.
  - 중앙 세션 관리 시스템을 설계했다하더라도, 이 시스템이 장애가 일어나면 시스템 전체에 문제가 생길 수 있음.
- CORS(Cross-Origin Resource Sharing)
  - 웹 애플리케이션에서 세션을 관리하기 위해 쿠키를 사용한다.
  - 하지만 쿠키는 단일 도메인 및 서브 도메인에서만 작동하도록 설계되어 있음.
  - 멀티 디바이스 환경에서 관리가 어렵다.

(HTTP REST 아키텍처 스타일 윈칙 중 무상태성이라는 원칙을 위반하기도 한다.)

이러한 세션 기반 인증의 한계를 개선하기 위해 등장한 방법이 **토큰 기반 인증**이다.

토큰 기반 인증 방식은 인증받은 사용자들에게 토큰을 발급하고, 서버에 요청할 때 헤더에 토큰을 함께 보내도록 하여 유효성을 검사하는 방식으로, 사용자의 인증 정보를 서버나 세션에 유지하지 않아도 되는 Stateless한 구조를 갖는다.

-----------------

### 쿠키 vs 세션

**1.저장위치**

- 쿠키 : 클라이언트에 파일로 저장
- 세션 : 서버에 저장

**2.보안**

- 쿠키 : 클라이언트 로컬에 저장되기 떄문에 변질되거나 request에서 스니핑당할 우려가 있어서 보안 취약
- 세션 : 쿠키를 이용해서 세션id만 저장하고 그것으로 구분해서 서버에서 처리하기 떄문에 비교적 안전 (보안 면에서 쿠키보다 우수)

**3.라이프 사이클**

- 쿠키 : 만료시간은 있지만 파일로 저장되기 떄문에 브라우저를 종료해도 계속해서 정보가 남아 있을수 있음. 만료기간을 넉넉히 잡아두면 쿠키삭제 할 때까지 유지될수도 있음.
- 세션 : 만료기간을 정할수는 있지만 브라우저가 종료되면 그에 상관없이 삭제

**4.속도**

- 쿠키 : 쿠키에 정보가 있기 떄문에 서버에 요청시 속도가 빠르다.
- 세션 : 정보가 서버에 있기 떄문에 처리가 요구되어 비교적으로 느림

```
세션이 쿠키에 비해 사용성이나 보안 측면에서 나아보이는데, 굳이 쿠키를 함께 사용하는 이유가 뭘까?

답은 세션은 서버 자원을 사용한다는 점에 있다. 세션은 서버에 저장되기 때문에 사용자가 늘어날수록 상태 유지를 위해 소모되는 자원이 상당하다. 때문에 서버의 부하를 줄이고, 응답 속도를 높이기 위해서는 쿠키와 세션의 적절한 병행이 필요하다.
```

-----------------

### 웹 스토리지(Web Storage)

> 클라이언트에 데이터를 저장할 수 있도록 HTML5부터 새롭게 지원하는 저장소

**특징**

- 키(Key)와 값(Value)의 쌍 형태로 데이터를 저장한다.
- 쿠키와 달리, 서버에 전송되지 않으므로 서버에 부담이 가지 않는다.
- 기능 자체는 쿠키와 유사하지만, 쿠키는 약 4KB까지 밖에 저장 공간을 이용하지 못하는 반면에 웹 스토리지는 약 5MB까지 저장 공간을 이용할 수 있다.
- 쿠키와 달리, 필요한 경우에만 꺼내 쓰는 것이므로 자동 전송의 위험성이 없다. 다른 도메인에서 요청하는 경우에는, 꺼내 쓰고 싶어도 도메인 단위로 접근이 제한되는 특성 덕분에 값을 꺼내 쓸 수 없다. (CSRF 안전)
- 쿠키와 달리, 대략 5MB까지의 데이터를 저장할 수 있으며 유효 기간이 존재하지 않는다.
- HTML5를 지원하지 않는 브라우저에서는 사용할 수 없다.
- 종류로는 로컬 스토리지(Local Storage)와 세션 스토리지(Session Storage)가 있다.

**로컬 스토리지(Local Storage)**

- window.localStorage 객체
- **브라우저를 종료해도 유지되는 데이터, 명시적으로 지우지 않는 한 영구적으로 저장**
- 도메인별로 생성, 다른 도메인의 로컬 스토리지에는 접근 불가
- 서로 다른 브라우저 탭 - 동일한 도메인 => 동일한 로컬 스토리지 사용
- 지속적으로 필요한 정보를 저장하기 좋음 (ex. 자동 로그인)

**세션 스토리지(Session Storage)**

- window.sessionStorage 객체
- 탭/윈도우 단위로 세션 스토리지가 생성된다. 탭/윈도우를 닫으면 데이터 삭제됨. (window 객체와 동일한 유효 범위 및 라이프 사이클을 가짐)
- 다른 탭/윈도우 - 같은 도메인 => 다른 세션 스토리지 생성
- 서로 다른 세션 스토리지 간 영향을 주지 않으며 독립적으로 동작
- 잠시 동안 필요한 정보를 저장하기 좋음 (ex. 입력 폼 저장, 일회성 로그인 등)

-----------------

## 토큰기반인증(JWT)

### 토큰

#### **토큰이란?**

- 인증에 필요한 정보들을 암호화시킨 토큰
- 데이터 전달시에 HTTP헤더에 실어서 전송

#### **토큰의 구성**

- Header : 암호화할 방식(alg), 타입(type)
- Payload : 서버에서 보낼 데이터
- Verify Signature : Base64 방식으로 인코딩한 Header,payload 그리고 SECRET KEY를 더한 후 서명한 데이터

#### **동작과정**

1. 사용자가 로그인
2. 서버에서는 계정정보를 읽어 사용자를 확인 후, 사용자의 고유한 ID값을 부여한 후, 기타 정보와 함께 Payload에 저장
3. JWT 토큰의 유효기간을 설정
4. 암호화할 SECRET KEY를 이용해 ACCESS TOKEN을 발급
5. 사용자는 Access Token을 받아 저장한 후, 인증이 필요한 요청마다 토큰을 헤더에 실어 전송
6. 서버에서는 해당 토큰의 Verify Signature를 SECRET KEY로 복호화한 후, 조작 여부, 유효기간을 확인
7. 검증이 완료된다면, Payload를 디코딩하여 사용자의 ID에 맞는 데이터를 획득

#### **토큰의 특징**

- stateless하며 클라이언트에 저장되기 때문에 쿠키처럼 서버의 부담이 없으면서도 서버의 비밀키로 사인되기 때문에 쿠키보다 안전
- 헤더와 내용이 암호화가 아닌 인코딩만 되어있다는 특징상 필요한 정보를 서버를 거치지 않고 클라이언트가 알아서 사용할 수 있음(바꿔 말하면 비밀번호 등의 민감한 정보를 payload에 담으면 안 된다!)
- 단, 토큰이 통째로 탈취될 경우에는 유효 기간이 지나기 전까지 계속 사용하는 것을 막을 수 없어, 보안상의 문제가 될 수 있음
  - 이를 보완하기 위해 탈취가 감지되거나 제보될 시 서버에서 토큰을 무력화시키도록 블랙리스트를 따로 관리하는 방식을 사용

[서버기반인증/토큰기반 인증 비교의 사본](https://www.notion.so/c0f2d953888a46d4b423a5271a66229f)

## Quiz

```
Q. 서버기반인증방식과 토큰기반인증방식의 차이점
```

```
Q. 클라이언트가 요청을 하고자할때 서버로 부터 받은 쿠키가 여러개 있을 경우 쿠키 전달은 어떻게 이루어지는가? (쿠키 모두를 전송하는지 / 특정 쿠키만을 전송하는지)
```

```
Q. 세션은 언제 만료되는가?
```

```
Q. 쿠키와 세션 중 세션이 더 보안상 우수한 방법인데 굳이 쿠키를 쓰는 이유는?
```

```
Q. JWT가 탈취되었을 경우를 대비 서버에서 취할 수 있는 예방책은?
```

```
Q. 쿠키와 웹 스토리지를 어떻게 구분해서 사용해야할까? (어떠한 경우에 쿠키를 쓰고, 어떤 경우에 웹 스토리지를 쓸지)
```

```
Q. 쿠키와 캐시의 차이점
```



## 참고한 URL

- https://interconnection.tistory.com/74
- https://hahahoho5915.tistory.com/32
- https://it-eldorado.tistory.com/90
- [https://chrisjune-13837.medium.com/web-%EC%BF%A0%ED%82%A4-%EC%84%B8%EC%85%98%EC%9D%B4%EB%9E%80-aa6bcb327582](https://chrisjune-13837.medium.com/web-쿠키-세션이란-aa6bcb327582)
- [https://velog.io/@stay136/%EA%B8%B0%EC%88%A0-%EC%BF%A0%ED%82%A4%EC%99%80-%EC%84%B8%EC%85%98%EC%9D%98-%EC%B0%A8%EC%9D%B4](https://velog.io/@stay136/기술-쿠키와-세션의-차이)
- https://untitledtblog.tistory.com/47
- [https://velog.io/@hellozin/%EC%BF%A0%ED%82%A4-%EC%84%B8%EC%85%98-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EC%9B%B9-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80](https://velog.io/@hellozin/쿠키-세션-그리고-웹-스토리지)
- https://mangkyu.tistory.com/55

- [쉽게 알아보는 서버 인증 1편(세션/쿠키 , JWT)](https://tansfil.tistory.com/58)

- [WeareSoft/tech-interview](https://github.com/WeareSoft/tech-interview/blob/master/contents/network.md#쿠키와-세션)